apply plugin: 'com.android.library'
apply plugin: 'kotlin-android'

// Java Toolchain Configuration
java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(17)
    }
}

repositories {
  google()
  mavenCentral()
  // Add JitPack repository to resolve com.github.libxposed:api dependency
  maven { url 'https://jitpack.io' }
}

android {
  compileSdkVersion rootProject.ext.compileSdk
  namespace 'com.wobbz.framework'
  
  defaultConfig {
    minSdkVersion rootProject.ext.minSdk
    targetSdkVersion rootProject.ext.targetSdk
    
    compileOptions {
      sourceCompatibility rootProject.ext.javaVersion
      targetCompatibility rootProject.ext.javaVersion
    }
    
    // Use the standard annotation processor configuration approach
    javaCompileOptions {
      annotationProcessorOptions {
        // Remove the includeCompileClasspath property as it's no longer supported
        // Set appropriate arguments if needed for annotation processors
        arguments = [
          modulePrefix: 'com.wobbz.framework'
        ]
      }
    }
  }
  
  buildTypes {
    release {
      minifyEnabled false
      proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
    }
  }
  
  // Include generated resources in the build output
  sourceSets {
    main {
      resources {
        srcDirs += "${buildDir}/generated/resources/xposed"
      }
    }
  }
  
  // Configure lint to ignore errors
  lintOptions {
    abortOnError false
    checkReleaseBuilds false
    disable 'MissingPermission'
  }
  
  // Disable Jetify transform for annotation processor dependencies
  /*configurations.all {
    if (it.name.contains('AnnotationProcessor')) {
      attributes.attribute(Attribute.of('artifactType', String), 'java-classes-directory')
    }
  }*/
}

configurations {
    implementation {
        canBeResolved = false
        canBeConsumed = true
    }
    api {
        canBeResolved = false
        canBeConsumed = true
    }
    compileOnly {
        canBeResolved = true
        canBeConsumed = false
    }
}

repositories {
    flatDir {
        dirs 'libs'
        dirs "${rootProject.projectDir}/../libxposed-api/api/build/outputs/aar"
    }
}

dependencies {
  // XPosed APIs - use the local AAR file
  compileOnly files('libs/xposed-api.aar')
  
  // For annotation processing
  implementation 'androidx.annotation:annotation:1.5.0'
  
  // Google Auto Service for annotation processing - REMOVED
  // compileOnly 'com.google.auto.service:auto-service-annotations:1.0.1'
  // annotationProcessor 'com.google.auto.service:auto-service:1.1.1'
  
  // Add Android tools for annotation processing
  // compileOnly 'org.androidannotations:androidannotations-api:4.8.0'
  // annotationProcessor 'org.androidannotations:androidannotations:4.8.0'
  
  // Remove tools.jar dependency as it's not available in newer JDKs
  // compileOnly files("${System.getProperty('java.home')}/../lib/tools.jar")
  
  // Square's JavaPoet for code generation
  implementation 'com.squareup:javapoet:1.13.0'
  
  // JSON processing for settings and config
  implementation 'com.google.code.gson:gson:2.10.1'
  implementation "org.json:json:20231013"
  
  // Android UI components and layouts
  implementation 'androidx.appcompat:appcompat:1.6.1'
  implementation 'androidx.core:core-ktx:1.9.0'
  
  // Testing dependencies
  testImplementation 'junit:junit:4.13.2'
}

// Hot-swap configuration
ext {
  hotSwap = [
    adbPath: findAdbPath(),
    targetDevice: null, // Will use first device if null
    moduleId: 'com.wobbz.lsposedframework',
    dataDir: '/data/data/com.wobbz.lsposedframework',
    remoteApkPath: '/data/local/tmp/framework-update.apk',
    lsposedServiceAction: 'io.github.lsposed.manager.RELOAD'
  ]
}

// Find ADB path
def findAdbPath() {
  def adbPath = null
  
  // Check from Android SDK
  def androidHome = System.getenv('ANDROID_HOME')
  if (androidHome) {
    def adb = new File(androidHome, 'platform-tools/adb')
    if (adb.exists()) {
      adbPath = adb.absolutePath
    }
  }
  
  // Check from Android SDK root
  if (!adbPath) {
    def androidSdkRoot = System.getenv('ANDROID_SDK_ROOT')
    if (androidSdkRoot) {
      def adb = new File(androidSdkRoot, 'platform-tools/adb')
      if (adb.exists()) {
        adbPath = adb.absolutePath
      }
    }
  }
  
  // Check from PATH
  if (!adbPath) {
    def osName = System.getProperty('os.name').toLowerCase()
    def isWindows = osName.contains('windows')
    def command = isWindows ? 'where adb' : 'which adb'
    def process = command.execute()
    process.waitFor()
    if (process.exitValue() == 0) {
      adbPath = process.text.trim()
    }
  }
  
  return adbPath
}

// Custom tasks for framework functionality
tasks.register('processAnnotations') {
  group = 'framework'
  description = 'Process XPosed plugin annotations and generate metadata files'
  
  doLast {
    println "Processing annotations and generating metadata files..."
    
    // Create output directories
    def outputDir = file("${buildDir}/generated/source/xposed")
    def resourcesDir = file("${buildDir}/generated/resources/xposed")
    outputDir.mkdirs()
    resourcesDir.mkdirs()
    
    // This approach can't directly use our Java classes since they're not compiled yet
    // Instead, we'll manually create the files with the required content
    
    // Create module.prop file
    def modulePropFile = new File(resourcesDir, "module.prop")
    modulePropFile.text = """id=com.wobbz.lsposedframework
name=LSPosed Framework
version=1.0.0
versionCode=1
author=Wobbz
description=A framework for LSPosed modules
"""
    
    // Create xposed_init file
    def xposedInitFile = new File(resourcesDir, "xposed_init")
    xposedInitFile.text = "com.wobbz.framework.generated.XposedEntryPoint"
    
    println "Created module.prop and xposed_init files in ${resourcesDir}"
  }
}

// Add dependency on processAnnotations task
preBuild.dependsOn processAnnotations

tasks.register('generateSettingsUI') {
  group = 'framework'
  description = 'Generate UI from settings JSON schemas'
  
  doLast {
    println "Generating settings UI..."
    // This will be implemented with actual code later
  }
}

tasks.register('checkDependencies') {
  group = 'framework'
  description = 'Check for module dependency conflicts'
  
  doLast {
    println "Checking module dependencies..."
    // This will be implemented with actual code later
  }
}

tasks.register('packageOverlays') {
  group = 'framework'
  description = 'Package resource overlays'
  
  doLast {
    println "Packaging resource overlays..."
    // This will be implemented with actual code later
  }
}

tasks.register('runDevServer') {
  group = 'framework'
  description = 'Run hot-reload development server'
  
  doLast {
    println "Starting hot-reload development server..."
    // This will be implemented with actual code later
  }
}

tasks.register('buildUpdate') {
  group = 'framework'
  description = 'Build update package for distribution'
  
  doLast {
    println "Building update package..."
    // This will be implemented with actual code later
  }
}

tasks.register('signUpdate') {
  group = 'framework'
  description = 'Sign update package with Ed25519 key'
  
  doLast {
    println "Signing update package..."
    // This will be implemented with actual code later
  }
}

tasks.register('uploadToCDN') {
  group = 'framework'
  description = 'Upload update package to CDN'
  
  doLast {
    println "Uploading update package to CDN..."
    // This will be implemented with actual code later
  }
}

tasks.register('hotSwap') {
  group = 'framework'
  description = 'Hot-swap framework or modules to device for instant updating'
  dependsOn 'assembleDebug'
  
  doLast {
    println "Performing hot-swap to device..."
    
    // Check that we have ADB
    if (!project.ext.hotSwap.adbPath) {
      throw new GradleException("Could not find ADB. Make sure Android SDK is properly set up.")
    }
    
    def adbPath = project.ext.hotSwap.adbPath
    def targetDevice = project.ext.hotSwap.targetDevice
    def deviceArg = targetDevice ? "-s ${targetDevice}" : ""
    
    // Check for connected devices
    def deviceCheckCmd = "${adbPath} ${deviceArg} devices"
    def deviceProcess = deviceCheckCmd.execute()
    deviceProcess.waitFor()
    def deviceOutput = deviceProcess.text
    
    // Ensure at least one device is connected
    if (!deviceOutput.contains("\tdevice")) {
      throw new GradleException("No devices connected. Connect a device and try again.")
    }
    
    // Get the APK file
    def apkFile = new File("${buildDir}/outputs/apk/debug/framework-debug.aar")
    if (!apkFile.exists()) {
      throw new GradleException("Debug APK not found. Build failed?")
    }
    
    // Push to device
    println "Pushing APK to device..."
    def pushCmd = "${adbPath} ${deviceArg} push ${apkFile.absolutePath} ${project.ext.hotSwap.remoteApkPath}"
    def pushProcess = pushCmd.execute()
    pushProcess.waitFor()
    if (pushProcess.exitValue() != 0) {
      throw new GradleException("Failed to push APK to device: ${pushProcess.err.text}")
    }
    
    // Install on device
    println "Installing APK on device..."
    def installCmd = "${adbPath} ${deviceArg} shell su -c 'pm install -r ${project.ext.hotSwap.remoteApkPath}'"
    def installProcess = installCmd.execute()
    installProcess.waitFor()
    if (installProcess.exitValue() != 0) {
      throw new GradleException("Failed to install APK on device: ${installProcess.err.text}")
    }
    
    // Trigger LSPosed to reload modules
    println "Triggering LSPosed to reload modules..."
    def reloadCmd = "${adbPath} ${deviceArg} shell am broadcast -a ${project.ext.hotSwap.lsposedServiceAction}"
    def reloadProcess = reloadCmd.execute()
    reloadProcess.waitFor()
    if (reloadProcess.exitValue() != 0) {
      throw new GradleException("Failed to trigger LSPosed reload: ${reloadProcess.err.text}")
    }
    
    println "Hot-swap complete! Framework has been updated and reloaded."
  }
}

// Task for hot-swapping individual modules
tasks.register('hotSwapModule') {
  group = 'framework'
  description = 'Hot-swap a specific module to device'
  
  doLast {
    def moduleName = project.hasProperty('module') ? project.property('module') : null
    if (!moduleName) {
      throw new GradleException("Please specify a module name with -Pmodule=ModuleName")
    }
    
    def moduleDir = new File("${rootProject.projectDir}/modules/${moduleName}")
    if (!moduleDir.exists() || !moduleDir.isDirectory()) {
      throw new GradleException("Module ${moduleName} not found")
    }
    
    println "Building module ${moduleName}..."
    def buildCmd = "./gradlew :modules:${moduleName}:assembleDebug"
    def buildProcess = buildCmd.execute(null, rootProject.projectDir)
    buildProcess.consumeProcessOutput(System.out, System.err)
    buildProcess.waitFor()
    if (buildProcess.exitValue() != 0) {
      throw new GradleException("Failed to build module ${moduleName}")
    }
    
    def moduleApk = new File("${moduleDir}/build/outputs/apk/debug/${moduleName}-debug.aar")
    if (!moduleApk.exists()) {
      throw new GradleException("Module APK not found. Build failed?")
    }
    
    // Get ADB connection info
    def adbPath = project.ext.hotSwap.adbPath
    def targetDevice = project.ext.hotSwap.targetDevice
    def deviceArg = targetDevice ? "-s ${targetDevice}" : ""
    
    // Check for connected devices
    def deviceCheckCmd = "${adbPath} ${deviceArg} devices"
    def deviceProcess = deviceCheckCmd.execute()
    deviceProcess.waitFor()
    def deviceOutput = deviceProcess.text
    
    // Ensure at least one device is connected
    if (!deviceOutput.contains("\tdevice")) {
      throw new GradleException("No devices connected. Connect a device and try again.")
    }
    
    // Push to device
    println "Pushing module APK to device..."
    def remoteModulePath = "/data/local/tmp/${moduleName}-update.apk"
    def pushCmd = "${adbPath} ${deviceArg} push ${moduleApk.absolutePath} ${remoteModulePath}"
    def pushProcess = pushCmd.execute()
    pushProcess.waitFor()
    if (pushProcess.exitValue() != 0) {
      throw new GradleException("Failed to push APK to device: ${pushProcess.err.text}")
    }
    
    // Install on device
    println "Installing module APK on device..."
    def installCmd = "${adbPath} ${deviceArg} shell su -c 'pm install -r ${remoteModulePath}'"
    def installProcess = installCmd.execute()
    installProcess.waitFor()
    if (installProcess.exitValue() != 0) {
      throw new GradleException("Failed to install APK on device: ${installProcess.err.text}")
    }
    
    // Trigger LSPosed to reload modules
    println "Triggering LSPosed to reload modules..."
    def reloadCmd = "${adbPath} ${deviceArg} shell am broadcast -a ${project.ext.hotSwap.lsposedServiceAction}"
    def reloadProcess = reloadCmd.execute()
    reloadProcess.waitFor()
    if (reloadProcess.exitValue() != 0) {
      throw new GradleException("Failed to trigger LSPosed reload: ${reloadProcess.err.text}")
    }
    
    println "Hot-swap complete! Module ${moduleName} has been updated and reloaded."
  }
} 