package com.wobbz.framework.processor;

import android.content.Context;
import android.content.pm.PackageManager;
import android.content.res.Resources;
import android.util.Log;

import com.wobbz.framework.IHotReloadable;
import com.wobbz.framework.IModulePlugin;
import com.wobbz.framework.PluginManager;
import com.wobbz.framework.annotations.HotReloadable;
import com.wobbz.framework.annotations.XposedPlugin;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import io.github.libxposed.api.XposedInterface;

/**
 * Handles the discovery and loading of LSPosed modules based on the metadata
 * generated by the annotation processor.
 *
 * <p>This class is responsible for:</p>
 * <ul>
 *   <li>Finding modules in the classpath using the {@code xposed_init} file</li>
 *   <li>Loading and initializing module classes annotated with {@link XposedPlugin}</li>
 *   <li>Reading module metadata from {@code module.prop} files</li>
 *   <li>Identifying hot-reloadable modules and their configuration</li>
 * </ul>
 */
public class ModuleDiscovery {
    private static final String TAG = "ModuleDiscovery";
    private static final String XPOSED_INIT_PATH = "assets/xposed_init";
    private static final String MODULE_PROP_PREFIX = "META-INF/module_";
    private static final String MODULE_PROP_SUFFIX = ".prop";
    private static final String HOTRELOAD_MODULES_LIST = "META-INF/hotreload/modules.list";
    private static final String HOTRELOAD_PORT_SUFFIX = ".port";
    
    private final Context mContext;
    private final ClassLoader mClassLoader;
    
    /**
     * Creates a new ModuleDiscovery instance.
     *
     * @param context The context to use for resource loading.
     */
    public ModuleDiscovery(Context context) {
        this.mContext = context;
        this.mClassLoader = context.getClassLoader();
    }
    
    /**
     * Discovers and registers all modules with the PluginManager.
     * 
     * @param xposedInterface The XposedInterface instance to pass to modules.
     * @return The number of successfully loaded modules.
     */
    public int discoverAndRegisterModules(XposedInterface xposedInterface) {
        PluginManager pluginManager = PluginManager.getInstance();
        List<String> moduleClassNames = loadModuleClassNames();
        int loadedCount = 0;
        
        for (String className : moduleClassNames) {
            try {
                Class<?> moduleClass = mClassLoader.loadClass(className);
                if (!IModulePlugin.class.isAssignableFrom(moduleClass)) {
                    Log.w(TAG, "Module class " + className + " does not implement IModulePlugin, skipping.");
                    continue;
                }
                
                XposedPlugin annotation = moduleClass.getAnnotation(XposedPlugin.class);
                if (annotation == null) {
                    Log.w(TAG, "Module class " + className + " is missing @XposedPlugin annotation, skipping.");
                    continue;
                }
                
                IModulePlugin module = (IModulePlugin) moduleClass.newInstance();
                pluginManager.registerModule(module);
                loadedCount++;
                
                Log.i(TAG, "Successfully loaded module: " + className + " (" + annotation.name() + ")");
            } catch (Exception e) {
                Log.e(TAG, "Failed to load module class: " + className, e);
            }
        }
        
        if (xposedInterface != null) {
            pluginManager.setXposedInterface(xposedInterface);
        }
        
        Log.i(TAG, "Discovered and loaded " + loadedCount + " modules out of " + moduleClassNames.size() + " found");
        return loadedCount;
    }
    
    /**
     * Loads the list of module class names from the xposed_init file.
     *
     * @return A list of fully qualified class names for modules.
     */
    public List<String> loadModuleClassNames() {
        List<String> moduleClassNames = new ArrayList<>();
        try {
            InputStream is = mContext.getAssets().open(XPOSED_INIT_PATH);
            BufferedReader reader = new BufferedReader(new InputStreamReader(is));
            String line;
            while ((line = reader.readLine()) != null) {
                line = line.trim();
                if (!line.isEmpty() && !line.startsWith("#")) {
                    moduleClassNames.add(line);
                }
            }
            reader.close();
        } catch (IOException e) {
            Log.e(TAG, "Error reading xposed_init file", e);
        }
        return moduleClassNames;
    }
    
    /**
     * Loads metadata for all available modules.
     *
     * @return A map of module IDs to their metadata.
     */
    public Map<String, Properties> loadModuleMetadata() {
        Map<String, Properties> moduleMetadata = new HashMap<>();
        try {
            // List all files in the META-INF directory
            String[] assets = mContext.getAssets().list("META-INF");
            if (assets == null) {
                return moduleMetadata;
            }
            
            for (String asset : assets) {
                if (asset.startsWith("module_") && asset.endsWith(".prop")) {
                    String moduleId = asset.substring("module_".length(), asset.length() - ".prop".length());
                    Properties props = new Properties();
                    
                    try (InputStream is = mContext.getAssets().open("META-INF/" + asset)) {
                        props.load(is);
                        moduleMetadata.put(moduleId, props);
                    } catch (IOException e) {
                        Log.e(TAG, "Error loading properties for module: " + moduleId, e);
                    }
                }
            }
        } catch (IOException e) {
            Log.e(TAG, "Error listing module property files", e);
        }
        
        return moduleMetadata;
    }
    
    /**
     * Identifies hot-reloadable modules and their configuration.
     *
     * @return A map of module class names to their hot-reload port.
     */
    public Map<String, Integer> findHotReloadableModules() {
        Map<String, Integer> hotReloadModules = new HashMap<>();
        List<String> moduleClassNames = new ArrayList<>();
        
        try {
            // Try to load the hotreload modules list
            InputStream is = mContext.getAssets().open(HOTRELOAD_MODULES_LIST);
            BufferedReader reader = new BufferedReader(new InputStreamReader(is));
            String line;
            while ((line = reader.readLine()) != null) {
                line = line.trim();
                if (!line.isEmpty()) {
                    moduleClassNames.add(line);
                }
            }
            reader.close();
            
            // For each module, try to find its port configuration
            for (String className : moduleClassNames) {
                try {
                    String portFile = "META-INF/hotreload/" + className + HOTRELOAD_PORT_SUFFIX;
                    InputStream portIs = mContext.getAssets().open(portFile);
                    BufferedReader portReader = new BufferedReader(new InputStreamReader(portIs));
                    String portStr = portReader.readLine();
                    portReader.close();
                    
                    if (portStr != null && !portStr.isEmpty()) {
                        try {
                            int port = Integer.parseInt(portStr.trim());
                            hotReloadModules.put(className, port);
                        } catch (NumberFormatException e) {
                            Log.e(TAG, "Invalid port number for module: " + className, e);
                        }
                    }
                } catch (IOException e) {
                    // Use default port if no specific port is configured
                    Class<?> moduleClass = mClassLoader.loadClass(className);
                    HotReloadable annotation = moduleClass.getAnnotation(HotReloadable.class);
                    if (annotation != null) {
                        hotReloadModules.put(className, annotation.port());
                    } else {
                        Log.w(TAG, "Module listed as hot-reloadable but missing @HotReloadable annotation: " + className);
                    }
                } catch (ClassNotFoundException e) {
                    Log.e(TAG, "Hot-reloadable module class not found: " + className, e);
                }
            }
        } catch (IOException e) {
            Log.e(TAG, "Error loading hot-reloadable modules list", e);
            
            // Fallback: Try to discover modules that implement IHotReloadable directly
            try {
                List<String> allModules = loadModuleClassNames();
                for (String className : allModules) {
                    try {
                        Class<?> moduleClass = mClassLoader.loadClass(className);
                        if (IHotReloadable.class.isAssignableFrom(moduleClass)) {
                            HotReloadable annotation = moduleClass.getAnnotation(HotReloadable.class);
                            if (annotation != null) {
                                hotReloadModules.put(className, annotation.port());
                            }
                        }
                    } catch (ClassNotFoundException e1) {
                        Log.e(TAG, "Module class not found during fallback discovery: " + className, e1);
                    }
                }
            } catch (Exception e2) {
                Log.e(TAG, "Error during fallback hot-reloadable module discovery", e2);
            }
        }
        
        return hotReloadModules;
    }
} 